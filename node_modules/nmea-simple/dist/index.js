"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var APB_1 = require("./codecs/APB");
var BWC_1 = require("./codecs/BWC");
var DBT_1 = require("./codecs/DBT");
var DTM_1 = require("./codecs/DTM");
var GGA_1 = require("./codecs/GGA");
var GLL_1 = require("./codecs/GLL");
var GNS_1 = require("./codecs/GNS");
var GSA_1 = require("./codecs/GSA");
var GST_1 = require("./codecs/GST");
var GSV_1 = require("./codecs/GSV");
var HDG_1 = require("./codecs/HDG");
var HDM_1 = require("./codecs/HDM");
var HDT_1 = require("./codecs/HDT");
var MTK_1 = require("./codecs/MTK");
var MWV_1 = require("./codecs/MWV");
var RDID_1 = require("./codecs/RDID");
var RMC_1 = require("./codecs/RMC");
var VHW_1 = require("./codecs/VHW");
var VTG_1 = require("./codecs/VTG");
var ZDA_1 = require("./codecs/ZDA");
var PacketStub_1 = require("./codecs/PacketStub");
var UnknownPacket_1 = require("./codecs/UnknownPacket");
var helpers_1 = require("./helpers");
var decoders = {
    APB: APB_1.decodeSentence,
    BWC: BWC_1.decodeSentence,
    DBT: DBT_1.decodeSentence,
    DTM: DTM_1.decodeSentence,
    GGA: GGA_1.decodeSentence,
    GLL: GLL_1.decodeSentence,
    GNS: GNS_1.decodeSentence,
    GSA: GSA_1.decodeSentence,
    GST: GST_1.decodeSentence,
    GSV: GSV_1.decodeSentence,
    HDG: HDG_1.decodeSentence,
    HDM: HDM_1.decodeSentence,
    HDT: HDT_1.decodeSentence,
    MTK: MTK_1.decodeSentence,
    MWV: MWV_1.decodeSentence,
    RDID: RDID_1.decodeSentence,
    RMC: RMC_1.decodeSentence,
    VHW: VHW_1.decodeSentence,
    VTG: VTG_1.decodeSentence,
    ZDA: ZDA_1.decodeSentence
};
var encoders = {
    DBT: DBT_1.encodePacket,
    GGA: GGA_1.encodePacket,
    GLL: GLL_1.encodePacket,
    GNS: GNS_1.encodePacket,
    HDM: HDM_1.encodePacket,
    HDT: HDT_1.encodePacket,
    MTK: MTK_1.encodePacket,
    MWV: MWV_1.encodePacket,
    VTG: VTG_1.encodePacket
};
var DefaultPacketFactory = /** @class */ (function () {
    function DefaultPacketFactory(ableToParseBadChecksum) {
        if (ableToParseBadChecksum === void 0) { ableToParseBadChecksum = false; }
        this.ableToParseBadChecksum = ableToParseBadChecksum;
    }
    DefaultPacketFactory.getParser = function (stub) {
        // Override for $PMTK314 and similar sentences
        if (stub.sentenceId.substr(0, 3) === "MTK") {
            return MTK_1.decodeSentence;
        }
        return decoders[stub.sentenceId];
    };
    DefaultPacketFactory.prototype.assemble = function (stub, fields) {
        var parser = DefaultPacketFactory.getParser(stub);
        if (parser) {
            return parser(stub, fields);
        }
        else {
            return this.assembleCustomPacket(stub, fields);
        }
    };
    DefaultPacketFactory.prototype.assembleCustomPacket = function (stub, fields) {
        return null;
    };
    return DefaultPacketFactory;
}());
exports.DefaultPacketFactory = DefaultPacketFactory;
var DEFAULT_PACKET_FACTORY = new DefaultPacketFactory();
function parseGenericPacket(sentence, factory) {
    var chxOk = true;
    if (!helpers_1.validNmeaChecksum(sentence)) {
        if (!factory.ableToParseBadChecksum) {
            throw Error("Invalid sentence: \"" + sentence + "\".");
        }
        chxOk = false;
    }
    var fields = sentence.split("*")[0].split(",");
    var stub = PacketStub_1.parseStub(fields[0], chxOk);
    var packet = factory.assemble(stub, fields);
    if (!packet) {
        throw Error("No known parser for sentence ID \"" + stub.sentenceId + "\".");
    }
    return packet;
}
exports.parseGenericPacket = parseGenericPacket;
function parseNmeaSentence(sentence) {
    return parseGenericPacket(sentence, DEFAULT_PACKET_FACTORY);
}
exports.parseNmeaSentence = parseNmeaSentence;
function encodeNmeaPacket(packet, talker) {
    if (talker === void 0) { talker = "P"; }
    if (packet === undefined) {
        throw new Error("Packet must be given.");
    }
    var encoder = encoders[packet.sentenceId];
    if (encoder) {
        return encoder(packet, talker);
    }
    else {
        throw Error("No known encoder for sentence ID \"" + packet.sentenceId + "\"");
    }
}
exports.encodeNmeaPacket = encodeNmeaPacket;
var UnsafePacketFactory = /** @class */ (function (_super) {
    __extends(UnsafePacketFactory, _super);
    function UnsafePacketFactory() {
        return _super.call(this, true) || this;
    }
    UnsafePacketFactory.prototype.assembleCustomPacket = function (stub, fields) {
        return UnknownPacket_1.decodeSentence(stub, fields);
    };
    return UnsafePacketFactory;
}(DefaultPacketFactory));
exports.UnsafePacketFactory = UnsafePacketFactory;
var UNSAFE_PACKET_FACTORY = new UnsafePacketFactory();
function parseUnsafeNmeaSentence(sentence) {
    return parseGenericPacket(sentence, UNSAFE_PACKET_FACTORY);
}
exports.parseUnsafeNmeaSentence = parseUnsafeNmeaSentence;
function getUnsafePacketId(packet) {
    return (packet.sentenceId === "?") ? packet.originalPacketId : packet.sentenceId;
}
exports.getUnsafePacketId = getUnsafePacketId;
